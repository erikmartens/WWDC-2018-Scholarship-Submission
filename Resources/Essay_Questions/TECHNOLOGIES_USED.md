My Playground allows the player to dive into an arcade-style version of the "Who Wants to Be a Millionaire" tv-show game. You will have to solve an endless stream of random questions, until you answer wrong. To help you there is a fifty-fifty-joker, that eliminates two of the four answer options. It gets reactivated every ten rounds after using it. You can save your highscores and also pause the game. The game features 80s-style music and sound effects.

The core technology for my quiz-game is SpriteKit. As an iOS developer with a focus on productivity apps, I did not have any prior experience with this framework. Therefore I had to get familiar with SpriteKit before crafting my idea. To keep things manageable I decided to intertwine with iOS frameworks for user input and making it the platform the Playground runs on.

I began by building the contents of my screens programmatically using SKSpriteKitNodes. The screens' child-nodes are built with SKNode subclasses that I customized. For example, my Buttons are SKShapeNode subclasses that contain a SKLabelNode and a filltexture. This makes them easily reusable. Setting new backgrounds to highlight button clicks is also trivial. A cool feature I built in is that tapping a button and dragging out of it before releasing will not result in a selection.

My plan is to release this Playground on GitHub after the judging process. Therefore I wanted to create a solid foundation using a proven architecture. My choice was the model-view-controller pattern since I am very familiar with it due to my previous projects. For a few screens of my game, it may seem to be curious (as for example a particular model class only consists of a single computed property with an implicit initializer), but I wanted to adhere to the principles throughout. 

I made use of the delegation pattern to create a separation of concerns. The game is initialized using the ApplicationMainController class. It is the application's main-delegate and is responsible for initializing the different controllers of the game. The ApplicationMainController is injected into the game's controllers via the ApplicationDelegate protocol. The controllers tell the delegate when they want their view to be loaded into the live-view or when they should be removed. Both the architecture the delegation of tasks make the game very modular, which should improve extendability. This would be interesting for those who would like to learn by tinkering with the code itself.

The third pillar of modularity is the use the FileStorageService, which is based on the FileManager class. With my quiz-game, I really disliked the idea of hard coding questions. Therefore they now live in a JSON-file and can easily be exchanged or added to. This is great for learners who want to take the game for what it is and study by playing it. The GameModel loads questions via the FileStorageService using custom DTOs and Codables, then provides them to the GameController. From there a question is randomly loaded into the view for each round.
